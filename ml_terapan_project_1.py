# -*- coding: utf-8 -*-
"""ML-Terapan-Project 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qPNKieBHdfcCSD2hdbXG3uRQ7B-EhXhb

# **Laporan Proyek Machine Learning - FAYADH RIZQI ZAMZAMI**

## **Domain Proyek**

Dalam beberapa dekade terakhir, pasar saham telah menjadi salah satu pilar utama dalam perekonomian global. Saham perusahaan teknologi seperti Microsoft (MSFT) memainkan peran penting dalam menentukan arah pasar keuangan dunia. Microsoft, sebagai salah satu perusahaan teknologi terbesar di dunia, memiliki pengaruh besar terhadap sektor teknologi dan ekonomi secara keseluruhan. Oleh karena itu, memahami dan memprediksi pergerakan harga saham Microsoft menjadi sangat penting, baik bagi investor individu maupun institusi keuangan.
Prediksi harga saham adalah salah satu tantangan terbesar dalam dunia keuangan karena sifatnya yang sangat dinamis dan dipengaruhi oleh berbagai faktor, seperti kondisi ekonomi global, laporan keuangan perusahaan, sentimen pasar, dan peristiwa geopolitik. Dengan menggunakan pendekatan machine learning dan analisis time series, kita dapat membangun model prediktif yang mampu memberikan wawasan tentang pergerakan harga saham di masa depan.


**Mengapa Masalah Ini Penting untuk Diselesaikan?**

- Bagi Investor: Prediksi harga saham dapat membantu investor membuat keputusan yang lebih baik dalam membeli atau menjual saham, sehingga memaksimalkan keuntungan dan meminimalkan risiko.
- Bagi Perusahaan: Perusahaan dapat menggunakan prediksi ini untuk memahami bagaimana sentimen pasar terhadap kinerja mereka dan merencanakan strategi bisnis yang lebih baik.
- Bagi Peneliti: Proyek ini memberikan peluang untuk mengeksplorasi teknik machine learning dan deep learning dalam domain keuangan, yang merupakan salah satu bidang penelitian yang berkembang pesat.

**Hasil Riset Terkait:**
- Penelitian sebelumnya menunjukkan bahwa algoritma seperti ARIMA (AutoRegressive Integrated Moving Average) dan LSTM (Long Short-Term Memory) sangat efektif dalam memprediksi data time series, termasuk harga saham. ARIMA bekerja dengan baik untuk data yang memiliki pola musiman, sedangkan LSTM unggul dalam menangkap pola kompleks dan hubungan jangka panjang dalam data historis.
- Sebuah studi oleh Fischer dan Krauss (2018) menunjukkan bahwa model deep learning seperti LSTM dapat mengungguli metode tradisional dalam memprediksi pergerakan harga saham, dengan akurasi yang lebih tinggi dalam berbagai skenario pasar.

**Referensi :**

- [Fischer, T., & Krauss, C. (2018). "Deep Learning with Long Short-Term Memory Networks for Financial Market Predictions."](https://www.sciencedirect.com/science/article/abs/pii/S0377221717310652)

## **Business Understanding**

### Problem Statements

- Bagaimana cara memprediksi harga saham Microsoft dengan akurasi yang lebih tinggi dibandingkan metode tradisional?
- Bagaimana cara mengatasi tantangan dalam memprediksi harga saham di tengah volatilitas pasar yang meningkat?

### Goals

Menjelaskan tujuan dari pernyataan masalah:
- Mengembangkan model machine learning yang dapat memprediksi harga saham Microsoft (MSFT) dengan akurasi yang lebih tinggi dibandingkan dengan metode tradisional. Model ini diharapkan dapat memberikan prediksi yang lebih tepat dalam kondisi pasar yang dinamis.

- Mengimplementasikan teknik yang dapat meningkatkan ketahanan model terhadap fluktuasi pasar yang meningkat. Dengan demikian, model dapat memberikan prediksi yang lebih stabil dan dapat diandalkan meskipun dalam kondisi pasar yang tidak menentu.

### Solution statements
- Mengembangkan sebuah model yang dapat membantu memprediksi harga saham Microsoft (MSFT) dengan lebih baik. Dengan menggunakan data historis yang tersedia, model diharapkan dapat memberikan wawasan yang lebih jelas tentang pergerakan harga di masa depan. Mengevaluasi seberapa baik model ini bekerja dengan mengukur rata-rata kesalahan antara prediksi dan harga sebenarnya, sehingga investor dapat membuat keputusan yang lebih cerdas.
- Mengimplementasikan teknik yang dapat meningkatkan ketahanan model terhadap fluktuasi pasar yang meningkat. Dengan pendekatan ini, model diharapkan dapat memberikan prediksi yang lebih stabil meskipun dalam kondisi pasar yang tidak menentu.

## **Data Understanding**
Dalam proyek ini, saya menggunakan dataset harga saham Microsoft (MSFT) yang mencakup data historis dari tahun 1986 hingga 12 Mei 2025. Dataset ini berisi informasi penting mengenai pergerakan harga saham Microsoft, yang dapat digunakan untuk analisis dan prediksi harga di masa depan. Data ini diambil dari [Kaggle](https://www.kaggle.com/datasets/muhammadatiflatif/complete-microsoft-stock-dataset-19862025?resource=download), datanya sudah sesuai dengan [Yahoo Finance](https://finance.yahoo.com/quote/MSFT/history/?period1=511108200&period2=1747802492) yang merupakan sumber terpercaya untuk data pasar saham.

Selanjutnya uraikanlah seluruh variabel atau fitur pada data. Sebagai contoh:  

### Variabel-variabel dalam Dataset Saham Microsoft (MSFT) :
- **Date:** Tanggal transaksi yang mencerminkan harga saham.
- **Open:** Harga pembukaan saham pada hari tersebut.
- **High:** Harga tertinggi yang dicapai saham pada hari tersebut.
- **Low:** Harga terendah yang dicapai saham pada hari tersebut.
- **Close:** Harga penutupan saham pada hari tersebut.
- **Volume:** Jumlah saham yang diperdagangkan pada hari tersebut.
- **Adj Close:** Harga penutupan yang disesuaikan, yang memperhitungkan dividen dan pemecahan saham.

**Rubrik/Kriteria Tambahan (Opsional)**:
- Melakukan beberapa tahapan yang diperlukan untuk memahami data, contohnya teknik visualisasi data atau exploratory data analysis.

#### **LOAD DATASET**
"""

#Import Library

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from xgboost import XGBRegressor
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score, mean_absolute_percentage_error
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.svm import SVR
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Dropout
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.optimizers import Adam

file_path = 'MSFT_1986-03-13_2025-05-12.csv'
df = pd.read_csv(file_path)

"""#### **Exploratory Data Analysis**"""

df

df.shape

df.info()

df.describe()

"""#### **Penjelasan**

- Dataset memiliki 9.868 baris dan 7 kolom
- terdapat fitur seperti open, high, low, close, adj_close, dan volume serta date
- Serta describe untuk frequensi
  - Count: Menunjukkan jumlah total entri untuk setiap kolom. Sebagian besar kolom memiliki 9868 entri, kecuali kolom date yang memiliki 9867 entri, menunjukkan bahwa ada satu nilai yang hilang atau tidak terdaftar.
  - Unique: Menunjukkan jumlah nilai unik dalam setiap kolom. Misalnya, kolom date memiliki 9867 nilai unik, yang berarti setiap tanggal dalam dataset adalah unik. Kolom open, high, low, close, adj_close, dan volume memiliki jumlah nilai unik yang lebih sedikit, menunjukkan bahwa ada beberapa harga yang berulang.
  - Top: Menunjukkan nilai yang paling sering muncul (frekuensi tertinggi) dalam setiap kolom. Misalnya, untuk kolom open, nilai tertinggi adalah 2.65625, yang muncul paling banyak.
  - Freq: Menunjukkan frekuensi dari nilai yang paling sering muncul. Misalnya, nilai open yang paling sering muncul memiliki frekuensi 18, yang berarti ada 18 hari di mana harga pembukaan saham adalah 2.65625.

#### **Check Missing Value**
"""

# Memeriksa missing values
missing_values = df.isnull().sum()

# Menampilkan jumlah missing values untuk setiap kolom
print("Jumlah Missing Values per Kolom:")
print(missing_values[missing_values > 0])  # Hanya menampilkan kolom yang memiliki missing values

# Menghapus baris yang memiliki missing values
df_cleaned = df.dropna()

# Memeriksa jumlah missing values setelah penanganan
print("\nJumlah Missing Values Setelah Penanganan:")
print(df_cleaned.isnull().sum())

# Menampilkan beberapa baris pertama dari dataset yang telah dibersihkan
print("\nData Setelah Menghapus Missing Values:")
print(df_cleaned.head())

# Memeriksa duplikasi data
duplicate_rows = df[df.duplicated()]

# Menampilkan jumlah baris yang duplikat
print("Jumlah Baris Duplikat:")
print(duplicate_rows.shape[0])

# Menampilkan baris yang duplikat
print("\nBaris yang Duplikat:")
print(duplicate_rows)

"""##### Disini sudah di atasi untuk missing value dan tidak ada duplikasi data

#### **Boxplot Visualization**
"""

# Mendefinisikan fitur numerik
numerical_features = [
    "open",
    "high",
    "low",
    "close",
    "adj_close",
    "volume"
]

# Pastikan semua kolom bertipe float (jika belum)
for col in numerical_features:
    df[col] = pd.to_numeric(df[col], errors='coerce')

# Boxplot untuk setiap fitur numerik (horizontal agar lebih rapi)
sns.set(style="whitegrid")
for num in numerical_features:
    plt.figure(figsize=(10, 4))
    sns.boxplot(x=df[num], color='skyblue')
    plt.title(f'Boxplot of {num.capitalize()}', fontsize=16)
    plt.xlabel(num.capitalize(), fontsize=14)
    plt.grid(axis='x')
    plt.xticks(fontsize=12)
    plt.yticks([])
    plt.tight_layout()
    plt.show()

"""##### **Penjelasan**
1. **Boxplot Open**
- Median nilai Open berada di kisaran 40–60.
- IQR (kotak tengah) menunjukkan bahwa sebagian besar harga pembukaan saham berada antara 30 hingga 80-an.
- Banyak outlier di atas nilai 100 dan di bawah 20.
- Hal ini menunjukkan bahwa meskipun sebagian besar saham dibuka dalam rentang normal, ada cukup banyak hari dengan nilai ekstrim (sangat rendah atau tinggi).

2. **Boxplot High**
- Median High sedikit lebih tinggi dari Open, sekitar 50–70.
- Terdapat distribusi yang mirip, namun dengan sebaran atas yang lebih panjang menunjukkan beberapa harga tertinggi di hari itu bisa sangat tinggi.
- Banyak outlier ekstrem di atas 150 bahkan hingga mendekati 200.

3. **Boxplot Low**
- Median harga Low lebih rendah dari Open, sekitar 40-an.
- Terdapat pencilan cukup banyak di bawah nilai 20, menandakan beberapa hari mengalami penurunan tajam.
- Outlier di bawah ini menunjukkan adanya volatilitas pasar di hari-hari tertentu.

4. **Boxplot Close**
- Median nilai penutupan (Close) berada di kisaran 50–60, mendekati nilai Open dan High.
- Terdapat simetri antara nilai Open, High, dan Close — ini umum di pasar saham.
- Outlier masih banyak dan terdistribusi cukup luas, menunjukkan pergerakan harian harga bisa sangat bervariasi.

5. **Boxplot Adj Close**
- Adj Close umumnya merefleksikan Close setelah disesuaikan untuk dividen dan split, dan distribusinya sangat mirip dengan Close.
- Median dan IQR sama, serta outliernya pun mirip.
- Artinya, penyesuaian tersebut tidak terlalu mengubah distribusi besar nilai penutupan.

6. **Boxplot Volume**
- Median volume transaksi sangat kecil dibandingkan range maksimalnya.
- IQR sangat sempit (di dekat 0), tetapi terdapat outlier ekstrem yang mencapai lebih dari 1 miliar volume transaksi.
- Hal ini menunjukkan bahwa sebagian besar hari memiliki volume kecil, tapi ada beberapa hari dengan volume transaksi yang sangat tinggi — bisa jadi karena berita besar, pengumuman keuangan, atau volatilitas pasar.

#### **EDA Univariate Analysis**
"""

# Mengatur gaya visualisasi
sns.set(style="whitegrid")

# Membuat figure dan axes untuk visualisasi histogram
fig, axes = plt.subplots(2, 3, figsize=(18, 10))
fig.suptitle('Univariate Analysis of Microsoft Stock Features', fontsize=20)

# Loop untuk membuat histogram
for i, num in enumerate(numerical_features):
    sns.histplot(df[num], bins=30, kde=True, ax=axes[i // 3, i % 3], color='skyblue')
    axes[i // 3, i % 3].set_title(f'Distribution of {num.capitalize()}', fontsize=16)
    axes[i // 3, i % 3].set_xlabel(num.capitalize(), fontsize=14)
    axes[i // 3, i % 3].set_ylabel('Frequency', fontsize=14)

# Menyesuaikan layout
plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

# Statistik Deskriptif
print("Statistik Deskriptif:")
print(df[numerical_features].describe())

"""##### **Penjelsan**

1. **Distribusi Harga (Open, High, Low, Close, Adj Close):**
- Semua fitur harga memiliki distribusi miring ke kanan (right-skewed).
- Mayoritas harga berada di bawah 100, dengan beberapa outlier mencapai lebih dari 460.
- Nilai Adj Close lebih rendah karena telah disesuaikan dengan dividen dan stock split.

2. **Distribusi Volume:**
- Volume transaksi juga skewed ke kanan.
- Sebagian besar hari memiliki volume di kisaran 20–100 juta.
- Terdapat outlier besar dengan volume mencapai 1 miliar transaksi.

Distribusi yang miring dan kehadiran outlier menunjukkan bahwa data mencakup periode waktu panjang dengan perubahan harga dan aktivitas yang signifikan.
Outlier signifikan dapat mempengaruhi analisis lanjutan seperti regresi atau machine learning.


"""

# Konversi kolom date ke datetime jika belum
df['date'] = pd.to_datetime(df['date'])

# Tambahkan fitur kategorikal turunan dari tanggal
df['year'] = df['date'].dt.year
df['month'] = df['date'].dt.month
df['day_of_week'] = df['date'].dt.day_name()
df['quarter'] = df['date'].dt.quarter
df['is_month_start'] = df['date'].dt.is_month_start
df['is_month_end'] = df['date'].dt.is_month_end

# List fitur kategorikal untuk divisualisasikan
categorical_features = ['year', 'month', 'day_of_week', 'quarter', 'is_month_start', 'is_month_end']

# Plot Countplot (Univariate Categorical)
fig, axes = plt.subplots(2, 3, figsize=(20, 10))
fig.suptitle('Categorical Feature Distribution from Date Column', fontsize=20)

for i, feature in enumerate(categorical_features):
    ax = axes[i // 3, i % 3]
    sns.countplot(data=df, x=feature, ax=ax, palette='magma')
    ax.set_title(f'{feature.replace("_", " ").title()}', fontsize=14)
    ax.set_xlabel(feature.replace("_", " ").title(), fontsize=12)
    ax.set_ylabel("Count", fontsize=12)
    if df[feature].nunique() > 6:
        ax.tick_params(axis='x', rotation=45)

plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

"""##### **Penjelasan**

1. Year (Tahun)
Distribusi jumlah data per tahun relatif merata dari sekitar tahun 1986 hingga 2020. Setiap tahun menyumbang sekitar 240–260 data, kecuali tahun terakhir (kemungkinan 2020) yang memiliki jumlah lebih sedikit—mungkin karena data belum lengkap di akhir tahun.

2. Month (Bulan)
Distribusi data cukup merata di semua bulan. Bulan ke-3 (Maret), 8 (Agustus), dan 10 (Oktober) terlihat sedikit lebih tinggi. Artinya, data tidak terlalu bias terhadap bulan tertentu.

3. Day of Week (Hari dalam Minggu)
Distribusi cukup merata antara hari Senin hingga Jumat. Selisih kecil menunjukkan tidak ada hari kerja yang sangat mendominasi, walau hari Selasa dan Rabu sedikit lebih sering muncul.

4. Quarter (Kuartal)
Data terdistribusi hampir sama untuk setiap kuartal (Q1 sampai Q4). Ini menandakan tidak ada kuartal dalam setahun yang secara signifikan lebih sering direpresentasikan.

5. Is Month Start (Awal Bulan)
Mayoritas data bukan dari hari pertama bulan (False), hanya sebagian kecil dari data yang berasal dari awal bulan (True). Ini sesuai dengan ekspektasi karena hanya satu hari setiap bulan yang merupakan awal bulan.

6. Is Month End (Akhir Bulan)
Sama seperti pada awal bulan, mayoritas data bukan dari akhir bulan (False). Hanya sebagian kecil data berasal dari akhir bulan (True), yang juga masuk akal karena hanya satu hari di setiap bulan yang merupakan akhir bulan.

#### **EDA Multivariate Analysis**
"""

# 1. Heatmap Korelasi
plt.figure(figsize=(10, 8))
correlation_matrix = df[numerical_features].corr()
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap="coolwarm", square=True)
plt.title('Heatmap Korelasi Antar Fitur Numerik', fontsize=16)
plt.show()

# 2. Pairplot untuk Hubungan Antar Fitur
sns.pairplot(df[numerical_features], diag_kind="kde", corner=True, plot_kws={'alpha': 0.6})
plt.suptitle('Pairplot Antar Fitur Numerik', y=1.02, fontsize=16)
plt.show()

# Membuat kategori berdasarkan rentang harga penutupan (close)
df['price_range'] = pd.cut(df['close'], bins=[0, 50, 100, 150, 200, 250, 300],
                           labels=['0-50', '50-100', '100-150', '150-200', '200-250', '250-300'])

# Mendefinisikan fitur numerik untuk analisis
numerical_features = ["open", "high", "low", "adj_close", "volume"]

# Loop untuk membuat visualisasi distribusi fitur numerik berdasarkan kategori price_range
for col in numerical_features:
    plt.figure(figsize=(10, 6))
    sns.boxplot(data=df, x='price_range', y=col, palette='Set2')
    plt.title(f"Distribution of {col.capitalize()} by Price Range", fontsize=16)
    plt.xlabel("Price Range (Close)", fontsize=14)
    plt.ylabel(col.capitalize(), fontsize=14)
    plt.xticks(rotation=45)
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.show()

"""##### **Penjelasan**

1. Heatmap Korelasi Antar Fitur Numerik
Interpretasi Statistik:
- Korelasi antar fitur open, high, low, close, dan adj_close adalah 1.00 (sangat tinggi)
  - Artinya semua harga ini sangat saling berkaitan (mungkin karena mereka berasal dari data pasar harian yang sama).
  - Jika salah satu naik, yang lain juga cenderung naik — kemungkinan fitur ini redundan dan dapat direduksi (misal pakai hanya close atau adj_close saja untuk modeling).

- Volume memiliki korelasi negatif sedang (-0.36) terhadap semua harga (open, close, dll)
  - Ini berarti ketika volume perdagangan meningkat, harga cenderung sedikit turun — indikasi adanya tekanan jual (selling pressure).
  - Namun nilai -0.36 tidak cukup kuat untuk menjadi indikator tunggal.

2. Pairplot Antar Fitur Numerik
Interpretasi Statistik:
Distribusi Harga (diagonal bagian atas):
- Semua fitur harga (open, high, low, close, adj_close) memiliki distribusi mirip log-normal, yaitu condong ke kiri dengan ekor kanan panjang (positive skewness).
  - Menunjukkan bahwa sebagian besar harga berada di rentang rendah, dengan sedikit outlier harga tinggi.

Hubungan antar harga (di bawah diagonal):
Terlihat garis linear sangat tajam → menguatkan korelasi 1.00 dari heatmap.
- Hubungan ini deterministik, artinya fitur-fitur ini membawa informasi yang sangat mirip.

Hubungan harga dengan volume:
Titik-titik tersebar dan tidak membentuk pola linier.
- Menunjukkan korelasi lemah, dan hal ini selaras dengan korelasi -0.36 di heatmap.
- Bisa jadi volume memiliki pengaruh non-linear atau dipengaruhi faktor eksternal lain.

Distribusi volume (paling bawah kanan):
Sangat right-skewed (berekor panjang ke kanan).
- Artinya, sebagian besar transaksi terjadi dalam volume kecil, namun ada beberapa hari dengan volume ekstrem (outlier).

## **Data Preperation**

#### **Handling Outliers**

Kode mengidentifikasi outlier menggunakan metode IQR pada setiap fitur numerik, lalu menerapkan winsorization (mengganti nilai ekstrem dengan batas atas/bawah) daripada menghapusnya, dengan batas toleransi 3 IQR untuk data keuangan.

Bertujuan untuk mengatasi nilai ekstrem tanpa mengurangi jumlah data training dengan mempertahankan bentuk distribusi yang lebih natural.
Penjelasan Output:
"""

# Handling outliers for all relevant numerical features
numerical_features = ['open', 'high', 'low', 'close', 'adj_close', 'volume']
original_shape = df.shape[0]

# Menggunakan IQR method untuk semua fitur numerik utama
for feature in numerical_features:
    Q1 = df[feature].quantile(0.25)
    Q3 = df[feature].quantile(0.75)
    IQR = Q3 - Q1

    # Filter outlier lebih konservatif (3 IQR) untuk data keuangan
    lower_bound = Q1 - 3 * IQR
    upper_bound = Q3 + 3 * IQR

    # Menandai outlier
    outlier_mask = (df[feature] < lower_bound) | (df[feature] > upper_bound)
    print(f"Jumlah outlier di {feature}: {outlier_mask.sum()}")

    # Winsorization sebagai alternatif menghapus outlier
    df[feature] = np.where(df[feature] < lower_bound, lower_bound, df[feature])
    df[feature] = np.where(df[feature] > upper_bound, upper_bound, df[feature])

print(f"Shape asli: {original_shape}, Shape setelah winsorization: {df.shape[0]}")

# Visualisasi setelah treatment
fig, axes = plt.subplots(3, 2, figsize=(18, 15))
fig.suptitle('Boxplots After Outlier Treatment', fontsize=16)

for i, feature in enumerate(numerical_features):
    row, col = i // 2, i % 2
    sns.boxplot(x=df[feature], ax=axes[row, col], color='skyblue')
    axes[row, col].set_title(f'Boxplot of {feature}')
    axes[row, col].grid(axis='x', linestyle='--', alpha=0.7)

plt.tight_layout(rect=[0, 0, 1, 0.97])
plt.show()

"""##### **Penjelasan**

Output menunjukkan sejumlah besar outlier pada fitur harga (>1200 outlier) tetapi sedikit pada volume (89 outlier), dan jumlah baris data tetap sama sebelum dan sesudah proses winsorization (9868 baris), membuktikan bahwa metode ini berhasil menjaga ukuran dataset sambil menormalisasi nilai ekstrem.

#### **Feature Engineering (Technical Indicators)**

Memperkaya dataset dengan indikator teknikal yang membantu model mengenali pola tren, momentum, volatilitas, dan musiman dalam pergerakan harga saham.

Lag Features (1-5 hari):
- Menggunakan shift() untuk mengakses harga dan volume dari 1-5 hari sebelumnya
- Contoh: close_lag2 memberikan harga penutupan dari 2 hari yang lalu
- Membantu model mempelajari dependensi temporal jangka pendek
Moving Averages:
- Menghitung rata-rata bergerak dengan window 7, 14, dan 30 hari
- Implementasi dengan rolling(window).mean()
- Menghilangkan noise harian dan menangkap tren jangka menengah
RSI (14 hari):
- Mengukur kecepatan dan perubahan pergerakan harga
- Algoritma: menghitung ratio average gain vs average loss
- RSI = 100 - (100 / (1 + RS)) dengan RS = average gain/average loss
- Nilai 0-100: >70 = overbought (potensi jenuh beli), <30 = oversold (potensi jenuh jual)
MACD:
- Menghitung EMA 12 dan EMA 26 hari dengan ewm()
- MACD line = EMA12 - EMA26
- Signal line = EMA9 dari MACD line
- Histogram = selisih antara MACD dan Signal (menunjukkan momentum)
Bollinger Bands:
- Mid band = MA 20 hari
- Upper/lower bands = MA ± (2 × standard deviation)
- Mengukur volatilitas dan memberikan level relatif harga (tinggi/rendah)
"""

# 1. Tambahkan lag lebih banyak (1-5 hari)
for lag in range(1, 6):
    df[f'close_lag{lag}'] = df['close'].shift(lag)
    df[f'volume_lag{lag}'] = df['volume'].shift(lag)

# 2. Moving averages dengan beberapa periode
for window in [7, 14, 30]:
    df[f'close_ma{window}'] = df['close'].rolling(window=window).mean()
    df[f'volume_ma{window}'] = df['volume'].rolling(window=window).mean()

# 3. Technical Indicators
# Relative Strength Index (RSI)
def calculate_rsi(data, window=14):
    delta = data.diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)

    avg_gain = gain.rolling(window=window).mean()
    avg_loss = loss.rolling(window=window).mean()

    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

df['rsi_14'] = calculate_rsi(df['close'], window=14)

# Moving Average Convergence Divergence (MACD)
df['ema_12'] = df['close'].ewm(span=12, adjust=False).mean()
df['ema_26'] = df['close'].ewm(span=26, adjust=False).mean()
df['macd'] = df['ema_12'] - df['ema_26']
df['macd_signal'] = df['macd'].ewm(span=9, adjust=False).mean()
df['macd_hist'] = df['macd'] - df['macd_signal']

# Bollinger Bands
window = 20
df['bollinger_mid'] = df['close'].rolling(window=window).mean()
df['bollinger_std'] = df['close'].rolling(window=window).std()
df['bollinger_upper'] = df['bollinger_mid'] + 2 * df['bollinger_std']
df['bollinger_lower'] = df['bollinger_mid'] - 2 * df['bollinger_std']

# 4. Volatility features
df['volatility_14'] = df['close'].rolling(window=14).std() / df['close'].rolling(window=14).mean()
df['daily_return'] = df['close'].pct_change()
df['return_volatility'] = df['daily_return'].rolling(window=14).std()

# 5. Tambahkan fitur berbasis tanggal
df['day_of_week'] = df['date'].dt.dayofweek
df['month'] = df['date'].dt.month
df['quarter'] = df['date'].dt.quarter
df['is_month_end'] = df['date'].dt.is_month_end.astype(int)

# Seasonal Decomposition (jika data cukup panjang)
from statsmodels.tsa.seasonal import seasonal_decompose

# Mendapatkan tren & musim jika data cukup panjang
try:
    decomposition = seasonal_decompose(df['close'], model='additive', period=252)  # 252 trading days in a year
    df['trend'] = decomposition.trend
    df['seasonality'] = decomposition.seasonal
    print("Seasonal decomposition berhasil diterapkan")
except:
    print("Data tidak cukup panjang untuk seasonal decomposition")

# Drop NA dari fitur turunan
df = df.dropna().reset_index(drop=True)
print(f"Jumlah fitur setelah feature engineering: {df.shape[1]}")
print(f"Fitur baru yang ditambahkan: {df.columns[-15:]}")

# Visualize beberapa technical indicators
plt.figure(figsize=(14, 10))
plt.subplot(3, 1, 1)
plt.plot(df['date'][-100:], df['close'][-100:], label='Close Price')
plt.plot(df['date'][-100:], df['bollinger_upper'][-100:], 'r--', label='Upper BB')
plt.plot(df['date'][-100:], df['bollinger_mid'][-100:], 'g--', label='Middle BB')
plt.plot(df['date'][-100:], df['bollinger_lower'][-100:], 'r--', label='Lower BB')
plt.title('Microsoft Stock with Bollinger Bands (Last 100 days)')
plt.legend()

plt.subplot(3, 1, 2)
plt.plot(df['date'][-100:], df['rsi_14'][-100:], label='RSI(14)')
plt.axhline(y=70, color='r', linestyle='--', alpha=0.5)
plt.axhline(y=30, color='r', linestyle='--', alpha=0.5)
plt.title('RSI Indicator')
plt.legend()

plt.subplot(3, 1, 3)
plt.plot(df['date'][-100:], df['macd'][-100:], label='MACD')
plt.plot(df['date'][-100:], df['macd_signal'][-100:], 'r--', label='Signal')
plt.bar(df['date'][-100:], df['macd_hist'][-100:], color='green', alpha=0.5, label='Histogram')
plt.title('MACD Indicator')
plt.legend()

plt.tight_layout()
plt.show()

"""##### **Penjelasan**

Visualisasi Bollinger Bands (Panel Atas):

- Grafik menunjukkan periode volatilitas ekstrem (Maret 2020) saat pandemi COVID-19
- Harga turun tajam dari $175 ke $135, menembus batas bawah Bollinger Band
- Band yang melebar pada Maret-April menandakan volatilitas tinggi
- Pemulihan gradual dari April ke Mei dengan harga kembali ke channel normal

Visualisasi RSI (Panel Tengah):
- Januari-Februari 2020: RSI di zone bullish (60-75)
- Awal Maret: RSI anjlok hampir ke 0 (oversold ekstrem) saat market crash
- Mid-Maret sampai April: Fase pemulihan dengan RSI naik bertahap dari zona oversold
- Mei: RSI kembali ke range normal dengan beberapa puncak mendekati 70
- Akhir periode: Spike RSI ke hampir 100, menandakan momentum bullish sangat kuat

Visualisasi MACD (Panel Bawah):
- Januari-Februari: MACD dan Signal positif (uptrend stabil)
- Maret: Bearish crossover diikuti MACD turun tajam ke -8 (downtrend kuat)
- April: Bullish crossover, histogram hijau menandakan momentum pembelian
- Mei: MACD stabil di area positif, mengkonfirmasi tren naik berkelanjutan

#### **Target Variable & Feature Selection**

1. Definisi Target Variable:

- Membuat 3 jenis target: harga penutupan hari berikutnya, arah perubahan, dan persentase return
- target_nextday_close diperoleh dengan shift(-1) untuk mengakses data hari berikutnya
- target_direction menggunakan np.where() untuk memberi label 1 (naik) atau 0 (turun)
2. Feature Engineering Tambahan:
- Membuat kategori harga numerik dengan pd.cut() dengan binning $0-$300 dan labels=False
- Mengkonversi kolom boolean is_month_start ke integer untuk analisis korelasi
3. Analisis Korelasi:
- Menggunakan corrwith() untuk menghitung korelasi setiap fitur dengan target
- Memvisualisasikan hasil dengan horizontal bar plot dan garis merah pada x=0
- Mengambil fitur dengan korelasi absolut tertinggi (top 15)
4. Penanganan Multikolinearitas:
- Membuat matriks korelasi antar top features dengan heatmap
- Menggunakan function remove_collinear() untuk menghilangkan fitur redundan
- Menerapkan threshold 0.85 (jika korelasi >0.85, salah satu fitur dihapus)
- Mengambil triangular upper matrix dengan np.triu() agar tidak menghitung korelasi berulang
"""

# Target: Bisa next-day close, future return, atau directional change
# 1. Next-day closing price
df['target_nextday_close'] = df['close'].shift(-1)  # Prediksi harga besok

# 2. Price change (naik/turun) - untuk klasifikasi
df['target_direction'] = np.where(df['close'].shift(-1) > df['close'], 1, 0)

# 3. Return (percentage change)
df['target_return'] = df['close'].pct_change(-1)  # Returns for the next day

# Feature selection dengan correlation
target = 'target_nextday_close'  # Pilih salah satu target

# Membuat price_range sebagai kategori NUMERIK (bukan string) dengan kode 0,1,2,...
df['price_range_numeric'] = pd.cut(df['close'],
                                  bins=[0, 50, 100, 150, 200, 250, 300],
                                  labels=False)  # Menggunakan label numerik

# Hapus tanggal dan kolom target lainnya serta kolom kategori untuk analisis korelasi
columns_to_drop = ['date', 'target_direction', 'target_return', 'price_range']

# Tambahkan kolom boolean ke kolom yang harus didrop
if 'is_month_start' in df.columns and df['is_month_start'].dtype == 'bool':
    df['is_month_start'] = df['is_month_start'].astype(int)  # Konversi bool ke int

correlation_features = df.drop(columns_to_drop, axis=1)

# Periksa tipe data untuk memastikan semua kolom numerik
print("Tipe data kolom setelah penyesuaian:")
print(correlation_features.dtypes)

# Korelasi dengan target
correlation_with_target = correlation_features.corrwith(df[target]).sort_values(ascending=False)

# Visualisasi korelasi dengan target
plt.figure(figsize=(10, 12))
correlation_with_target.plot(kind='barh', color='skyblue')
plt.title(f'Korelasi Fitur dengan {target}')
plt.axvline(x=0, color='red', linestyle='--')
plt.tight_layout()
plt.show()

# Pilih fitur berdasarkan korelasi (contoh: top 15)
top_features = correlation_with_target.abs().sort_values(ascending=False).head(15).index.tolist()
top_features = [f for f in top_features if f != target]  # Pastikan target tidak termasuk
print("Top features berdasarkan korelasi:")
print(top_features)

# Menghilangkan fitur dengan multikolinearitas tinggi
correlation_matrix = df[top_features].corr()
plt.figure(figsize=(12, 10))
sns.heatmap(correlation_matrix, annot=True, fmt=".2f", cmap="coolwarm")
plt.title('Korelasi Antar Top Features')
plt.tight_layout()
plt.show()

# Threshold untuk multikolinearitas (contoh: 0.85)
def remove_collinear(df, threshold=0.85):
    corr_matrix = df.corr().abs()
    upper = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(bool))
    collinear_features = [column for column in upper.columns if any(upper[column] > threshold)]
    print(f"Fitur dengan multikolinearitas tinggi (>{threshold}): {collinear_features}")
    return [col for col in df.columns if col not in collinear_features]

selected_features = remove_collinear(df[top_features], threshold=0.85)
print("Fitur yang dipilih setelah mengatasi multikolinearitas:")
print(selected_features)

"""#### **Penjelasan**

1. Visualisasi Korelasi dengan Target:
- Fitur berbasis harga (close, low, high, dll.) memiliki korelasi sangat tinggi (~0.99) dengan harga selanjutnya
- Fitur berbasis moving average dan Bollinger bands juga berkorelasi tinggi (0.90-0.98)
- Indikator momentum seperti MACD dan RSI memiliki korelasi moderat positif (0.10-0.40)
- Fitur berdasarkan volume menunjukkan korelasi negatif moderat (-0.40)
- Fitur kalender (day_of_week, month) hampir tidak berkorelasi (~0)
2. Heatmap Korelasi Antar Features:
- Semua fitur top-15 menunjukkan korelasi ekstrem tinggi satu sama lain (0.998-1.000)
- Warna merah gelap dominan di seluruh matriks menunjukkan redundansi informasi
- Bahkan EMA dan Bollinger bands, yang menggunakan formula berbeda, tetap berkorelasi >0.99 dengan harga dasar
3. Hasil Penanganan Multikolinearitas:
- 13 dari 14 fitur terdeteksi redundan dan dihapus karena korelasi >0.85
- Hanya 'close' yang tersisa sebagai fitur pilihan
- Menunjukkan bahwa dari perspektif korelasi linier, hampir semua fitur teknikal tidak memberikan informasi tambahan signifikan dibanding harga penutupan


Fenomena ini umum dalam data keuangan/saham dimana harga (open, high, low, close) dan turunannya sangat terkorelasi, memperlihatkan perlunya teknik dimensionality reduction atau model non-linier untuk menangkap pola yang lebih kompleks dari indikator teknikal.

#### **Normalisasi & Preprocessing Final**

Kode melakukan preprocessing akhir dengan mengidentifikasi dan mengkonversi kolom kategorikal menjadi one-hot encoding, mengubah kolom boolean menjadi integer, memfilter fitur berdasarkan hasil feature selection sebelumnya (hanya "close" yang terpilih), dan menormalisasi data input dan target menggunakan MinMaxScaler untuk membuat semua nilai berada dalam rentang 0-1.

Bertujuan mempersiapkan data untuk pemodelan machine learning dengan format dan skala yang tepat, sehingga model dapat belajar dengan optimal tanpa bias dari perbedaan rentang nilai variabel.
"""

# Pastikan tidak ada missing values
df = df.dropna()

# One-hot encoding untuk fitur kategorikal yang tersisa (jika ada)
# Pastikan kolom day_of_week sudah numerik sebelum proses selanjutnya
categorical_cols = df.select_dtypes(include=['object']).columns.tolist()
if categorical_cols:
    print(f"Melakukan one-hot encoding pada kolom kategorikal: {categorical_cols}")
    df = pd.get_dummies(df, columns=categorical_cols, drop_first=True)

# Pastikan kolom boolean dikonversi ke integer
bool_cols = df.select_dtypes(include=['bool']).columns.tolist()
for col in bool_cols:
    df[col] = df[col].astype(int)

# Pemilihan fitur final berdasarkan hasil feature selection
# Gunakan semua kolom selected_features dan kolumn hasil one-hot encoding (jika ada)
all_features = selected_features.copy()
encoded_cols = [col for col in df.columns if any(cat in col for cat in categorical_cols)] if categorical_cols else []
X_features = all_features + encoded_cols

# Filter fitur yang tersedia di df (untuk berjaga-jaga)
X_features = [col for col in X_features if col in df.columns and col != target]

print(f"Jumlah fitur setelah pemilihan: {len(X_features)}")
print(f"Contoh 10 fitur: {X_features[:10]}")

# Persiapkan data untuk model
X = df[X_features]
y = df[target]

# Normalisasi data
scaler = MinMaxScaler()
X_scaled = pd.DataFrame(scaler.fit_transform(X), columns=X.columns, index=X.index)

# Target-scaler untuk denormalisasi prediksi nanti
target_scaler = MinMaxScaler()
y_scaled = target_scaler.fit_transform(y.values.reshape(-1, 1)).flatten()

print("\nDimensi data setelah preprocessing:")
print(f"X: {X_scaled.shape}, y: {y_scaled.shape}")

"""##### **Penjelasan**

Output menunjukkan bahwa setelah preprocessing, dataset memiliki 8589 baris dengan hanya 1 fitur ('close') yang digunakan sebagai input, karena proses seleksi fitur sebelumnya menemukan bahwa variabel 'close' sudah cukup representatif dan fitur lainnya sangat redundan (multikolinear) dengan target prediksi.

#### **Train-Test Split Data**

Kode ini membagi dataset time series menjadi tiga bagian berurutan: training (70%), validation (15%), dan testing (15%), mempertahankan urutan kronologis yang penting untuk data deret waktu, kemudian memvisualisasikan pembagian ini dalam grafik yang menampilkan seluruh rentang waktu data saham Microsoft.

Bertujuan Membuat pemisahan data yang mematuhi prinsip time series (tidak random) untuk memastikan model dilatih pada data masa lalu, divalidasi pada periode tengah, dan dievaluasi pada data terbaru.
"""

# Split data dengan memperhatikan urutan waktu - untuk data time series
train_size = int(len(X_scaled) * 0.7)
val_size = int(len(X_scaled) * 0.15)

# Simpan tanggal untuk visualisasi nanti
dates = df['date'].values

X_train = X_scaled.iloc[:train_size]
X_val = X_scaled.iloc[train_size:train_size+val_size]
X_test = X_scaled.iloc[train_size+val_size:]

y_train = y_scaled[:train_size]
y_val = y_scaled[train_size:train_size+val_size]
y_test = y_scaled[train_size+val_size:]

dates_train = dates[:train_size]
dates_val = dates[train_size:train_size+val_size]
dates_test = dates[train_size+val_size:]

print(f"Training set: {X_train.shape[0]} samples, {X_train.shape[1]} features")
print(f"Validation set: {X_val.shape[0]} samples")
print(f"Test set: {X_test.shape[0]} samples")

# Visualisasi split
plt.figure(figsize=(14, 6))
plt.plot(dates[:train_size], df[target][:train_size], 'b-', label='Training')
plt.plot(dates[train_size:train_size+val_size], df[target][train_size:train_size+val_size], 'g-', label='Validation')
plt.plot(dates[train_size+val_size:], df[target][train_size+val_size:], 'r-', label='Test')
plt.title('Time Series Split untuk Target Variable')
plt.xlabel('Tanggal')
plt.ylabel('Target Value')
plt.legend()
plt.tight_layout()
plt.show()

"""##### **Penjelasan**

Visualisasi menunjukkan evolusi harga saham Microsoft dari 1988-2020 dengan tiga periode berbeda: data training (biru, 1988-2008) menampilkan periode volatilitas dot-com bubble dan stabilisasi, data validasi (hijau, 2008-2014) menangkap fase pemulihan post-krisis 2008, dan data testing (merah, 2014-2020) mencakup periode pertumbuhan agresif dengan pola kenaikan eksponensial—sebuah tantangan untuk model karena harus memprediksi regime harga yang berbeda dari data historisnya.

## Modeling

#### **Model Training & Selection**

Kode ini mengimplementasikan strategi model comparison untuk prediksi saham dengan pendekatan sistematis:

1. Fungsi Evaluasi Model:
- Mendefinisikan evaluate_model() untuk menghitung metrik standar: MAE, RMSE, R², MAPE, dan directional accuracy
- Menggunakan denormalisasi untuk mendapatkan nilai asli harga saham saat menghitung MAPE
- Menghitung directional accuracy yang menunjukkan seberapa akurat model memprediksi arah pergerakan harga (naik/turun)
2. Training Multiple Models:
- Linear Regression: Model paling sederhana yang mengasumsikan hubungan linier
- Random Forest: Ensemble learning dengan pohon keputusan (100 estimator)
- XGBoost: Gradient boosting optimized dengan learning rate 0.1
- Gradient Boosting: Implementasi scikit-learn untuk boosting
- LSTM Neural Network: Model deep learning untuk data sekuensial dengan:
  - Preprocessing khusus time series (membuat sequence windows 10 hari)
  - Arsitektur stacked LSTM dengan dropout untuk mencegah overfitting
  - Early stopping untuk menghentikan training jika tidak ada improvement
3. Visualisasi Perbandingan:
- Plot training history LSTM (loss vs epochs)
- Visualisasi perbandingan model dalam grid 2x2 yang menampilkan 4 metrik utama
- Highlight model terbaik untuk setiap metrik dengan warna hijau
"""

# Function untuk evaluasi model
def evaluate_model(y_true, y_pred, name="Model"):
    mae = mean_absolute_error(y_true, y_pred)
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    r2 = r2_score(y_true, y_pred)

    # Denormalisasi untuk menghitung MAPE
    y_true_orig = target_scaler.inverse_transform(y_true.reshape(-1, 1)).flatten()
    y_pred_orig = target_scaler.inverse_transform(y_pred.reshape(-1, 1)).flatten()
    mape = np.mean(np.abs((y_true_orig - y_pred_orig) / y_true_orig)) * 100

    # Directional accuracy (seberapa akurat prediksi arah naik/turun)
    if len(y_pred_orig) > 1:  # Minimal 2 data untuk menghitung direction
        pred_direction = np.where(np.diff(y_pred_orig) > 0, 1, 0)
        true_direction = np.where(np.diff(y_true_orig) > 0, 1, 0)
        directional_acc = np.mean(pred_direction == true_direction) * 100
    else:
        directional_acc = np.nan

    print(f"\n=== {name} Performance ===")
    print(f"MAE: {mae:.4f}")
    print(f"RMSE: {rmse:.4f}")
    print(f"MAPE: {mape:.2f}%")
    print(f"R²: {r2:.4f}")
    if not np.isnan(directional_acc):
        print(f"Directional Accuracy: {directional_acc:.2f}%")

    return {
        'model': name,
        'MAE': mae,
        'RMSE': rmse,
        'MAPE': mape,
        'R2': r2,
        'Dir_Acc': directional_acc if not np.isnan(directional_acc) else 0
    }

# 1. Linear Regression
model_lr = LinearRegression()
model_lr.fit(X_train, y_train)
y_pred_lr = model_lr.predict(X_val)
lr_metrics = evaluate_model(y_val, y_pred_lr, "Linear Regression")

# 2. Random Forest
model_rf = RandomForestRegressor(n_estimators=100, random_state=42)
model_rf.fit(X_train, y_train)
y_pred_rf = model_rf.predict(X_val)
rf_metrics = evaluate_model(y_val, y_pred_rf, "Random Forest")

# 3. XGBoost
model_xgb = XGBRegressor(n_estimators=100, learning_rate=0.1, random_state=42)
model_xgb.fit(X_train, y_train)
y_pred_xgb = model_xgb.predict(X_val)
xgb_metrics = evaluate_model(y_val, y_pred_xgb, "XGBoost")

# 4. Gradient Boosting
model_gb = GradientBoostingRegressor(n_estimators=100, learning_rate=0.1, random_state=42)
model_gb.fit(X_train, y_train)
y_pred_gb = model_gb.predict(X_val)
gb_metrics = evaluate_model(y_val, y_pred_gb, "Gradient Boosting")

# 5. LSTM (Deep Learning)
# Cek apakah dataset cukup besar untuk LSTM
if len(X_train) > 100:  # Minimal 100 data untuk LSTM
    # Reshape data untuk LSTM [samples, time steps, features]
    SEQUENCE_LENGTH = min(10, len(X_train) // 10)  # Dinamis, max 10 atau 1/10 dari data

    def create_sequences(X, y, seq_length=SEQUENCE_LENGTH):
        X_seq, y_seq = [], []
        for i in range(len(X) - seq_length):
            X_seq.append(X.iloc[i:i+seq_length].values)
            y_seq.append(y[i+seq_length])
        return np.array(X_seq), np.array(y_seq)

    X_train_lstm, y_train_lstm = create_sequences(X_train, y_train)
    X_val_lstm, y_val_lstm = create_sequences(X_val, y_val)

    print(f"LSTM training data shape: {X_train_lstm.shape}")

    # Build LSTM model - menyesuaikan dengan ukuran dataset
    lstm_units = min(50, X_train_lstm.shape[2] * 2)  # Dinamis berdasarkan jumlah fitur

    model_lstm = Sequential([
        LSTM(lstm_units, activation='relu', return_sequences=True,
             input_shape=(X_train_lstm.shape[1], X_train_lstm.shape[2])),
        Dropout(0.2),
        LSTM(lstm_units // 2, activation='relu'),
        Dropout(0.2),
        Dense(1)
    ])

    model_lstm.compile(optimizer=Adam(learning_rate=0.001), loss='mse')
    early_stop = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)

    # Batch size yang sesuai dengan ukuran dataset
    batch_size = min(32, len(X_train_lstm) // 10)

    history = model_lstm.fit(
        X_train_lstm, y_train_lstm,
        epochs=100,
        batch_size=batch_size,
        validation_data=(X_val_lstm, y_val_lstm),
        callbacks=[early_stop],
        verbose=1
    )

    # Visualisasi training history
    plt.figure(figsize=(10, 6))
    plt.plot(history.history['loss'], label='Training Loss')
    plt.plot(history.history['val_loss'], label='Validation Loss')
    plt.title('LSTM Training History')
    plt.xlabel('Epochs')
    plt.ylabel('Loss (MSE)')
    plt.legend()
    plt.grid(True)
    plt.show()

    # Prediksi dengan LSTM
    y_pred_lstm = model_lstm.predict(X_val_lstm).flatten()
    lstm_metrics = evaluate_model(y_val_lstm, y_pred_lstm, "LSTM")

    # Collect all model metrics
    models_comparison = pd.DataFrame([lr_metrics, rf_metrics, xgb_metrics, gb_metrics, lstm_metrics])
else:
    print("Dataset terlalu kecil untuk LSTM, hanya menggunakan model tradisional")
    models_comparison = pd.DataFrame([lr_metrics, rf_metrics, xgb_metrics, gb_metrics])

models_comparison.set_index('model', inplace=True)

# Visualisasi perbandingan model
metrics_to_plot = ['RMSE', 'MAE', 'R2', 'MAPE']
fig, axs = plt.subplots(2, 2, figsize=(16, 12))
titles = ['Root Mean Squared Error (Lower is Better)',
          'Mean Absolute Error (Lower is Better)',
          'R² Score (Higher is Better)',
          'Mean Absolute Percentage Error (Lower is Better)']

for i, (metric, title) in enumerate(zip(metrics_to_plot, titles)):
    row, col = i // 2, i % 2
    axs[row, col].bar(models_comparison.index, models_comparison[metric], color='skyblue')
    axs[row, col].set_title(title)
    if metric in ['R2']:
        # Untuk metrik dimana higher is better
        best_model = models_comparison[metric].idxmax()
        best_value = models_comparison[metric].max()
    else:
        # Untuk metrik dimana lower is better
        best_model = models_comparison[metric].idxmin()
        best_value = models_comparison[metric].min()

    axs[row, col].bar(best_model, models_comparison.loc[best_model, metric], color='green')
    axs[row, col].text(best_model, best_value * 1.05, 'Best', ha='center')
    axs[row, col].set_ylabel(metric)
    axs[row, col].grid(axis='y', linestyle='--', alpha=0.7)
    # Rotasi label jika terlalu panjang
    plt.setp(axs[row, col].get_xticklabels(), rotation=30, ha='right')

plt.tight_layout()
plt.show()

"""##### **Penjelasan**

1. Performa Model:
- Linear Regression menghasilkan performa terbaik (RMSE 0.0026, MAPE 1.02%)
- Model tree-based (RF, XGB, GB) performa sedikit lebih rendah (RMSE 0.0029-0.0039)
- LSTM performa signifikan lebih buruk (RMSE 0.0938, R² negatif -4.76)
- Semua model memiliki directional accuracy sekitar 50% (tidak lebih baik dari random)
2. LSTM Training History:
- Training loss turun cepat dari 0.0104 ke 0.0064 di awal training
- Validation loss berfluktuasi antara 0.0088-0.0102 tanpa pola perbaikan jelas
- Gap antara training dan validation loss mengindikasikan sedikit overfitting
3. Perbandingan Visual:
- Linear Regression (hijau) konsisten terbaik di semua metrik
- LSTM memiliki bar tertinggi (terburuk) di semua metrik kecuali directional accuracy
- R² LSTM negatif (-4.76) menunjukkan performa lebih buruk dari prediksi mean sederhana


Model Sederhana Unggul: Linear Regression mengungguli model kompleks, menunjukkan hubungan next-day close price dengan current close sangat linier pada data saham Microsoft. Kompleksitas ≠ Akurasi: Meskipun LSTM dirancang untuk data time series, performanya buruk dengan satu fitur, menunjukkan bahwa kompleksitas model tidak selalu berarti akurasi lebih baik. Directional Accuracy Rendah: Semua model gagal memprediksi arah pergerakan harga (~50%), meskipun magnitude prediksi akurat (MAPE rendah), menunjukkan bahwa fitur teknikal tambahan mungkin diperlukan untuk memprediksi arah. Insight Praktis: Untuk aplikasi trading nyata, model seperti Linear Regression dapat digunakan untuk prediksi harga, tetapi tidak dapat diandalkan untuk keputusan beli/jual berdasarkan prediksi arah.

#### **Best Model Evaluation on Test Set**

Kode ini melakukan evaluasi model terbaik pada dataset testing, mengikuti langkah-langkah sistematis:
1. Seleksi Model Terbaik: Mengidentifikasi model dengan RMSE terendah pada validation set (Linear Regression). Menyediakan mekanisme fallback jika model terpilih tidak tersedia
2. Pemrosesan Prediksi: Menerapkan model terbaik pada data test Mengolah data khusus jika model terpilih adalah LSTM (perlu sequence processing).Mengevaluasi performa dengan fungsi evaluate_model()
3. Denormalisasi Hasil: Mengkonversi output model dari nilai 0-1 kembali ke harga saham asli ($). Memastikan tanggal dan jumlah prediksi selaras untuk visualisasi
4. Visualisasi Komprehensif: Time-series plot: menampilkan prediksi vs nilai aktual sepanjang waktu. Error analysis: menampilkan error over time dan scatter plot prediksi vs aktual
"""

# Pilih model terbaik (berdasarkan RMSE terendah pada validation set)
best_model_name = models_comparison['RMSE'].idxmin()
print(f"\nModel terbaik berdasarkan RMSE: {best_model_name}")

# Evaluasi model terbaik pada test set
if best_model_name == "Linear Regression":
    best_model = model_lr
    y_pred_test = best_model.predict(X_test)
elif best_model_name == "Random Forest":
    best_model = model_rf
    y_pred_test = best_model.predict(X_test)
elif best_model_name == "XGBoost":
    best_model = model_xgb
    y_pred_test = best_model.predict(X_test)
elif best_model_name == "Gradient Boosting":
    best_model = model_gb
    y_pred_test = best_model.predict(X_test)
elif best_model_name == "LSTM" and 'model_lstm' in locals():
    # Prepare test data for LSTM
    X_test_lstm, y_test_lstm = create_sequences(X_test, y_test)
    y_pred_test = model_lstm.predict(X_test_lstm).flatten()
    y_test = y_test_lstm
else:
    print("Model LSTM tidak tersedia atau tidak terpilih sebagai model terbaik")
    # Fallback ke model terbaik kedua jika LSTM tidak tersedia
    second_best = models_comparison['RMSE'].sort_values().index[1]
    best_model_name = second_best
    if second_best == "Linear Regression":
        best_model = model_lr
    elif second_best == "Random Forest":
        best_model = model_rf
    elif second_best == "XGBoost":
        best_model = model_xgb
    elif second_best == "Gradient Boosting":
        best_model = model_gb
    y_pred_test = best_model.predict(X_test)

# Evaluasi model pada test set
test_metrics = evaluate_model(y_test, y_pred_test, f"{best_model_name} (Test Set)")

# Denormalisasi hasil untuk visualisasi
y_test_actual = target_scaler.inverse_transform(y_test.reshape(-1, 1)).flatten()
y_pred_actual = target_scaler.inverse_transform(y_pred_test.reshape(-1, 1)).flatten()

# Sesuaikan dates_test jika menggunakan LSTM (karena sequence length mengurangi jumlah sampel)
if best_model_name == "LSTM" and 'model_lstm' in locals():
    dates_test_adj = dates_test[SEQUENCE_LENGTH:]
else:
    dates_test_adj = dates_test

# Visualisasi hasil prediksi vs aktual
plt.figure(figsize=(16, 8))
plt.plot(dates_test_adj[-len(y_test_actual):], y_test_actual, label='Actual', color='blue')
plt.plot(dates_test_adj[-len(y_pred_actual):], y_pred_actual, label='Predicted', color='red', linestyle='--')
plt.title(f'Microsoft Stock Price Prediction using {best_model_name}')
plt.xlabel('Date')
plt.ylabel('Stock Price ($)')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Visualisasi error
plt.figure(figsize=(16, 6))
plt.subplot(1, 2, 1)
error = y_pred_actual - y_test_actual
plt.plot(dates_test_adj[-len(error):], error)
plt.title('Prediction Error Over Time')
plt.xlabel('Date')
plt.ylabel('Error ($)')
plt.grid(True)

plt.subplot(1, 2, 2)
plt.scatter(y_test_actual, y_pred_actual, alpha=0.5)
plt.plot([y_test_actual.min(), y_test_actual.max()], [y_test_actual.min(), y_test_actual.max()], 'r--')
plt.title('Predicted vs Actual')
plt.xlabel('Actual Price ($)')
plt.ylabel('Predicted Price ($)')
plt.grid(True)
plt.tight_layout()
plt.show()

"""##### **Penjelasan**

1. Metrik Performa:
- MAE: 0.0058 (nilai normalized) menunjukkan rata-rata error absolut
- RMSE: 0.0110 (nilai normalized) lebih sensitif terhadap error besar
- MAPE: 1.09% menunjukkan error hanya sekitar 1% dari nilai aktual (sangat baik)
- R²: 0.9973 menunjukkan model menjelaskan 99.73% variasi dalam data (fit sangat baik)
- Directional Accuracy: 47.44% (sedikit di bawah 50%, tidak lebih baik dari random)
2. Time Series Plot (Gambar 1):
- Prediksi (garis merah putus-putus) mengikuti dengan sangat dekat nilai aktual (garis biru)
- Terlihat trend kenaikan harga Microsoft dari ~$40 (2016) hingga ~$180 (2020)
- Model berhasil menangkap pola harga termasuk penurunan tajam di awal 2020 (COVID-19 crash)
- Track record yang konsisten di berbagai regime pasar (sideways, bullish, volatile)
3. Error Analysis (Gambar 2):
- Error Over Time (kiri): Mayoritas error berada dalam kisaran ±$2 hingga 2019

- Volatilitas error meningkat di 2020 dengan beberapa spike mencapai ±$20 saat COVID-19
- Scatter Plot (kanan): Titik-titik terdistribusi sangat dekat dengan garis 45° (perfect prediction)
- Kerapatan titik di sekitar garis diagonal mengkonfirmasi nilai R² tinggi (0.9973)

**Kesimpulan:**

Linear Regression menunjukkan performa excellent (MAPE 1.09%, R² 0.9973) untuk memprediksi harga saham Microsoft hari berikutnya, mengindikasikan bahwa harga pada satu hari sangat kuat memprediksi harga hari berikutnya. Namun, model gagal memprediksi arah pergerakan (directional accuracy 47.44%), yang menjadi limitasi untuk aplikasi trading yang mengandalkan prediksi naik/turun.

#### **Feature Importance Analysis**

Kode ini melakukan analisis kontribusi fitur terhadap prediksi, dengan pendekatan yang berbeda berdasarkan jenis model:
- Untuk model tree-based (RF, XGBoost, GB): Menggunakan feature_importances_ yang menunjukkan kontribusi relatif setiap fitur
- Untuk Linear Regression: Menggunakan koefisien model yang menunjukkan pengaruh langsung fitur terhadap prediksi

Karena Linear Regression adalah model terbaik, kode mengambil path kedua yang memproses koefisien model, mengurutkannya berdasarkan nilai absolut, dan memvisualisasikan hasilnya.
"""

# Analisis feature importance (untuk model tree-based)
if best_model_name in ["Random Forest", "XGBoost", "Gradient Boosting"]:
    # Dapatkan feature importance
    feature_importance = pd.DataFrame({
        'feature': X_train.columns,
        'importance': best_model.feature_importances_
    }).sort_values('importance', ascending=False)

    # Tampilkan top 15 fitur penting
    plt.figure(figsize=(12, 8))
    sns.barplot(x='importance', y='feature', data=feature_importance.head(15), palette='viridis')
    plt.title(f'Top 15 Most Important Features ({best_model_name})')
    plt.tight_layout()
    plt.show()

    print("\nTop 10 fitur paling penting:")
    print(feature_importance.head(10))
elif best_model_name == "Linear Regression":
    # Untuk model linear, kita bisa menggunakan koefisien
    coef = pd.DataFrame({
        'feature': X_train.columns,
        'coefficient': best_model.coef_
    }).sort_values('coefficient', key=abs, ascending=False)

    plt.figure(figsize=(12, 8))
    sns.barplot(x='coefficient', y='feature', data=coef.head(15), palette='viridis')
    plt.title('Top 15 Features with Highest Absolute Coefficients (Linear Regression)')
    plt.tight_layout()
    plt.show()

    print("\nTop 10 fitur dengan koefisien tertinggi:")
    print(coef.head(10))

"""##### **Penjelasan**

Output menampilkan visualisasi dan statistik:
- Diagram batang menunjukkan hanya satu fitur ('close') dengan koefisien 0.9993
- Output teks mengkonfirmasi bahwa 'close' adalah satu-satunya fitur yang digunakan


**Interpretasi:**

1. Koefisien Mendekati 1: Koefisien 0.9993 menunjukkan relasi yang sangat kuat dan hampir 1:1 antara harga penutupan saat ini dan harga besok hari
2. Implikasi Model: Model Linear Regression pada dasarnya memprediksi bahwa harga besok = 0.9993 × harga hari ini (mendekati efficient market hypothesis yang menyatakan hari ini adalah prediktor terbaik untuk besok)
3. Kesederhanaan Model: Dengan hanya satu fitur, model Linear Regression menjadi sangat sederhana (y = 0.9993x + c) namun sangat efektif dengan MAPE hanya 1.09%
4. Insight Perdagangan: Harga saham Microsoft menunjukkan kecenderungan "persistence" yang kuat, dimana pergerakan harga hari berikutnya sangat dipengaruhi oleh harga hari ini dengan sangat sedikit penyesuaian (< 0.1%)

Fakta bahwa model terbaik hanya menggunakan satu fitur karena multikolinearitas menegaskan bahwa untuk prediksi satu hari ke depan, indikator teknikal kompleks mungkin tidak memberikan nilai tambah dibanding harga terakhir.

#### **Kesimpulan Model**

Kode ini menyajikan ringkasan hasil prediksi saham Microsoft dengan metrik performa utama dan visualisasi akhir, menunjukkan perbandingan data historis terakhir, data aktual pengujian, dan prediksi model.
"""

print("\n=== KESIMPULAN PREDIKSI SAHAM MICROSOFT ===")
print(f"Model terbaik: {best_model_name}")
print(f"RMSE pada test set: {test_metrics['RMSE']:.4f}")
if 'Dir_Acc' in test_metrics and test_metrics['Dir_Acc'] > 0:
    print(f"Directional accuracy: {test_metrics['Dir_Acc']:.2f}%")
print(f"MAPE: {test_metrics['MAPE']:.2f}%")
print(f"R²: {test_metrics['R2']:.4f}")

# Contoh visualisasi prediksi masa depan
plt.figure(figsize=(14, 7))
plt.plot(dates_test[-30:], df[target].values[-30:], label='Data Terakhir', color='blue')
plt.plot(dates_test_adj[-len(y_test_actual):], y_test_actual, label='Aktual (Test)', color='green')
plt.plot(dates_test_adj[-len(y_pred_actual):], y_pred_actual, label='Prediksi', color='red', linestyle='--')
plt.title('Microsoft Stock Price - Historical dan Prediksi')
plt.xlabel('Tanggal')
plt.ylabel('Harga Saham ($)')
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

"""##### **Penjelasan**

1. **Metrik Performa:**

- Model Terbaik: Linear Regression - model paling sederhana mengungguli model kompleks lainnya
- RMSE: 0.0110 - indikasi error prediksi yang sangat rendah
- Directional Accuracy: 47.44% - sedikit di bawah prediksi acak (50%), menunjukkan keterbatasan model dalam memprediksi arah pergerakan
- MAPE: 1.09% - error persentase sangat rendah, menunjukkan akurasi magnitude yang excellent
- R²: 0.9973 - model menjelaskan 99.73% variasi data, fit yang hampir sempurna

2. **Visualisasi:**

Grafik menampilkan tren harga Microsoft dari 2015-2020 dengan tiga elemen:
- Data terakhir (biru)
- Data aktual test (hijau)
- Prediksi model (merah putus-putus)

Ketiga garis hampir sepenuhnya berhimpit, menunjukkan prediksi yang sangat akurat. Visualisasi juga menangkap tren kenaikan jangka panjang Microsoft dan volatilitas tinggi saat pandemi COVID-19 di awal 2020.

3. Kesimpulan:

Model Linear Regression dengan satu fitur ('close') terbukti sangat efektif untuk memprediksi magnitude harga saham Microsoft (MAPE 1.09%), namun terbatas dalam kemampuan memprediksi arah pergerakan. Ini mengilustrasikan prinsip pasar efisien - harga hari ini adalah prediktor terbaik untuk harga besok, dengan koefisien 0.9993 menunjukkan persistensi harga yang sangat kuat.

## Pemilihan Model Terbaik untuk Prediksi Saham Microsoft

Dalam proyek ini, saya mengevaluasi lima model berbeda untuk prediksi harga saham Microsoft: Linear Regression, Random Forest, XGBoost, Gradient Boosting, dan LSTM. Setelah analisis mendalam, **Linear Regression** terpilih sebagai model terbaik berdasarkan beberapa pertimbangan penting:

### 1. Perbandingan Metrik Performa

Linear Regression secara konsisten mengungguli model lain dalam semua metrik utama:

| Model | RMSE | MAPE | R² | Directional Accuracy |
|-------|------|------|----|--------------------|
| **Linear Regression** | **0.0026** | **1.02%** | **0.9955** | 49.18% |
| Random Forest | 0.0039 | 1.52% | 0.9902 | 49.73% |
| XGBoost | 0.0031 | 1.20% | 0.9938 | 49.57% |
| Gradient Boosting | 0.0029 | 1.15% | 0.9943 | 48.87% |
| LSTM | 0.0938 | 44.60% | -4.7688 | 50.67% |

Pada test set, Linear Regression mempertahankan performa excellent dengan RMSE 0.0110, MAPE 1.09%, dan R² 0.9973, membuktikan kemampuan generalisasi yang kuat.

### 2. Prinsip Parsimony (Kesederhanaan)

Linear Regression menawarkan keseimbangan optimal antara kompleksitas dan performa:

- **Occam's Razor**: Model paling sederhana dengan performa terbaik harus dipilih. Linear Regression hanya menggunakan satu parameter (koefisien 0.9993) namun mencapai akurasi tertinggi.
- **Interpretabilitas**: Formula prediktif yang jelas (harga_besok ≈ 0.9993 × harga_hari_ini) memberikan transparansi yang sulit didapat dari model black-box seperti ensemble trees atau neural networks.
- **Efisiensi Komputasi**: Training dan inferensi jauh lebih cepat dibanding model kompleks, penting untuk aplikasi real-time.

### 3. Stabilitas Model pada Berbagai Regime Pasar

Linear Regression menunjukkan ketahanan luar biasa dalam berbagai kondisi pasar:

- **Periode Sideways (2016)**: Model tetap akurat dalam kondisi pasar flat
- **Trend Bullish (2017-2019)**: Mengikuti tren kenaikan dengan presisi tinggi
- **Volatilitas Ekstrem (2020/COVID-19)**: Beradaptasi dengan baik pada penurunan dan pemulihan tajam

Model tree-based dan LSTM gagal menunjukkan keunggulan dalam menangani volatilitas, meskipun secara teoritis dirancang untuk pola non-linear.

### 4. Kesesuaian dengan Efficient Market Hypothesis

Koefisien 0.9993 pada Linear Regression menegaskan prinsip dalam teori pasar efisien bahwa harga saat ini merupakan prediktor terbaik untuk harga masa depan dengan penyesuaian minimal. Ini menjelaskan mengapa model sederhana dapat mengungguli model kompleks yang berpotensi overfitting terhadap noise.

### 5. Limitasi yang Sama pada Semua Model

Semua model, termasuk yang kompleks, gagal dalam memprediksi arah pergerakan harga (directional accuracy ~50%). Ini menunjukkan bahwa kompleksitas tambahan tidak menyelesaikan tantangan fundamental dalam prediksi arah harga saham.

### Kesimpulan

Linear Regression dipilih sebagai model terbaik karena memberikan akurasi tertinggi dengan kompleksitas terendah, sesuai dengan prinsip "less is more" dalam machine learning. Fakta bahwa model tersederhana mengungguli model canggih seperti LSTM menggarisbawahi sifat persistensi yang kuat dalam harga saham Microsoft dan pentingnya memahami karakteristik data sebelum menerapkan model kompleks.

Untuk pengembangan masa depan, fokus sebaiknya diarahkan pada meningkatkan directional accuracy, mungkin dengan menambahkan fitur-fitur eksternal seperti sentimen pasar atau faktor makroekonomi, bukan pada peningkatan kompleksitas model.

## **Evaluation**

Dalam proyek prediksi harga saham Microsoft ini, evaluasi model dilakukan dengan menggunakan beberapa metrik yang relevan untuk masalah regresi time series. Pemilihan metrik yang tepat sangat penting untuk menilai kinerja model dalam konteks prediksi harga saham.

### Metrik Evaluasi yang Digunakan

### 1. Root Mean Squared Error (RMSE)
**Formula:** $\text{RMSE} = \sqrt{\frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2}$

RMSE mengukur akar kuadrat dari rata-rata kesalahan kuadrat antara nilai prediksi dan nilai aktual. Metrik ini memberikan penalti lebih besar pada error yang besar, sehingga sangat berguna untuk mengevaluasi model yang perlu menghindari kesalahan besar dalam prediksi harga saham. Semakin kecil nilai RMSE, semakin akurat model.

### 2. Mean Absolute Error (MAE)
**Formula:** $\text{MAE} = \frac{1}{n} \sum_{i=1}^{n} |y_i - \hat{y}_i|$

MAE menghitung rata-rata nilai absolut dari error. Metrik ini lebih mudah diinterpretasi karena langsung menunjukkan besarnya kesalahan dalam unit yang sama dengan data asli (dollar). MAE tidak terpengaruh oleh outlier sebesar RMSE karena tidak mengkuadratkan error.

### 3. Mean Absolute Percentage Error (MAPE)
**Formula:** $\text{MAPE} = \frac{100\%}{n} \sum_{i=1}^{n} \left| \frac{y_i - \hat{y}_i}{y_i} \right|$

MAPE mengukur error sebagai persentase dari nilai aktual, sehingga memberikan perspektif relatif tentang seberapa besar kesalahan prediksi. Metrik ini sangat berguna dalam konteks investasi karena investor sering berpikir dalam persentase keuntungan/kerugian.

### 4. Coefficient of Determination (R²)
**Formula:** $\text{R}^2 = 1 - \frac{\sum_{i=1}^{n} (y_i - \hat{y}_i)^2}{\sum_{i=1}^{n} (y_i - \bar{y})^2}$

R² menunjukkan proporsi variasi dalam variabel target yang dapat dijelaskan oleh model. Nilai 1.0 berarti model menjelaskan semua variabilitas data, sementara nilai 0 berarti model tidak lebih baik dari memprediksi nilai mean. Nilai negatif menunjukkan model berkinerja lebih buruk daripada baseline.

### 5. Directional Accuracy
**Formula:** $\text{DirectionalAcc} = \frac{\text{Jumlah prediksi arah benar}}{\text{Total prediksi}} \times 100\%$

Directional Accuracy mengukur kemampuan model untuk memprediksi arah pergerakan harga (naik/turun), bukan besarnya perubahan. Metrik ini sangat penting untuk strategi trading karena keputusan beli/jual sering didasarkan pada prediksi arah pergerakan harga.

## Hasil Evaluasi Model

Berikut hasil evaluasi model Linear Regression (model terbaik) pada data testing:

| Metrik | Nilai | Threshold | Interpretasi |
|--------|-------|-----------|--------------|
| RMSE | 0.0110 | < 0.05 (baik) | Error kuadrat rata-rata sangat rendah |
| MAE | 0.0058 | < 0.03 (baik) | Model rata-rata meleset sekitar 0.58% dari nilai sebenarnya |
| MAPE | 1.09% | < 5% (sangat baik) | Error rata-rata hanya 1.09% dari nilai aktual |
| R² | 0.9973 | > 0.9 (sangat baik) | Model menjelaskan 99.73% variabilitas data |
| Directional Accuracy | 47.44% | > 50% (baik) | Model tidak dapat memprediksi arah pergerakan secara akurat |

## Interpretasi Hasil

1. **Akurasi Prediksi Nilai**: Model Linear Regression menunjukkan performa yang sangat baik dalam memprediksi nilai harga saham dengan MAPE hanya 1.09%. Artinya, rata-rata prediksi hanya meleset sekitar 1% dari harga aktual. Dalam konteks investasi, tingkat error ini sangat kecil dan dapat diandalkan untuk estimasi valuasi.

2. **Kekuatan Prediktif**: R² yang sangat tinggi (0.9973) menunjukkan bahwa model menjelaskan hampir seluruh variasi dalam data harga saham Microsoft, mengkonfirmasi bahwa model ini sangat cocok untuk data yang diberikan.

3. **Prediksi Arah Pergerakan**: Meskipun sangat akurat dalam memprediksi nilai, model memiliki directional accuracy di bawah 50% (47.44%), yang berarti model tidak lebih baik dari tebakan acak dalam memprediksi arah pergerakan harga. Ini adalah keterbatasan signifikan untuk aplikasi trading.

4. **Analisis Error**: Visualisasi error menunjukkan bahwa:
   - Sebagian besar error kecil (± $2) selama periode normal
   - Error meningkat saat volatilitas tinggi (awal 2020/COVID-19)
   - Error terdistribusi merata (tidak bias), yang mengindikasikan model yang seimbang

## Keterkaitan dengan Business Understanding

### Analisis Terhadap Problem Statement

1. **Problem Statement 1: "Bagaimana cara memprediksi harga saham Microsoft dengan akurasi yang lebih tinggi dibandingkan metode tradisional?"**
   
   Model Linear Regression yang dikembangkan telah berhasil menjawab problem statement ini dengan mencapai MAPE 1.09% dan R² 0.9973, yang jauh lebih baik dibandingkan metode tradisional pada umumnya seperti:
   - Moving Average sederhana: Umumnya menghasilkan MAPE 3-5% untuk prediksi next-day
   - Metode Naïve (menggunakan harga terakhir sebagai prediksi): MAPE sekitar 2%
   
   Walaupun model kita sederhana, kombinasi preprocessing yang tepat (winsorization outlier) dan feature selection yang efektif menghasilkan performa luar biasa untuk prediksi nilai absolut.

2. **Problem Statement 2: "Bagaimana cara mengatasi tantangan dalam memprediksi harga saham di tengah volatilitas pasar yang meningkat?"**
   
   Problem statement ini terjawab sebagian. Model menunjukkan:
   - Performa yang stabil pada periode volatilitas normal dengan MAPE di bawah 2%
   - Ketahanan relatif terhadap fluktuasi pasar berkat teknik winsorization
   - Namun, performa menurun pada volatilitas ekstrem seperti crash COVID-19
   
   Meskipun menunjukkan ketahanan pada volatilitas normal, model masih terbatas dalam menghadapi black swan events, menandakan perlunya strategi mitigasi tambahan.

### Pencapaian Goals

1. **Goal 1: "Mengembangkan model machine learning yang dapat memprediksi harga saham Microsoft dengan akurasi yang lebih tinggi dibandingkan metode tradisional."**
   
   Goal ini berhasil dicapai dengan sangat baik, terbukti dari:
   - MAPE 1.09% yang jauh di bawah threshold industri (5%)
   - R² 0.9973 menunjukkan kemampuan prediktif luar biasa
   - Performa konsisten di berbagai periode pasar normal
   
   Semua metrik menunjukkan model mampu memprediksi nilai harga saham Microsoft dengan akurasi sangat tinggi.

2. **Goal 2: "Mengimplementasikan teknik yang dapat meningkatkan ketahanan model terhadap fluktuasi pasar yang meningkat."**
   
   Goal ini tercapai sebagian:
   - Teknik winsorization terbukti efektif mengatasi outlier tanpa mengurangi data
   - Feature engineering komprehensif membantu model memahami pola pasar
   - Namun, directional accuracy rendah (47.44%) menunjukkan keterbatasan dalam merespon perubahan arah harga
   - Performa menurun signifikan pada volatilitas ekstrem

### Efektivitas Solution Statements

1. **Solution 1: "Mengembangkan sebuah model yang dapat membantu memprediksi harga saham Microsoft dengan lebih baik."**
   
   Solution ini terbukti sangat efektif untuk prediksi nilai absolut harga saham. Investor dapat memanfaatkan model ini untuk:
   - Proyeksi nilai portofolio jangka pendek dengan akurasi ~99%
   - Estimasi valuasi aset Microsoft dengan error minimal
   - Analisis skenario dan stress testing pada rentang harga normal
   
   Batasan praktis: tidak dapat diandalkan untuk keputusan trading berdasarkan perubahan arah harga.

2. **Solution 2: "Mengimplementasikan teknik yang dapat meningkatkan ketahanan model terhadap fluktuasi pasar yang meningkat."**
   
   Teknik-teknik yang diimplementasikan berhasil sebagian:
   - Winsorization efektif menangani outlier pada data historis
   - Train-test split kronologis memastikan model diuji pada data terbaru
   - Seleksi fitur mengeliminasi noise dan multikolinearitas
   
   Namun, keterbatasan model menghadapi volatilitas ekstrem menunjukkan perlunya pendekatan tambahan seperti ensemble models atau regime-switching approaches.

## Rekomendasi Pengembangan

Berdasarkan evaluasi komprehensif dan keterkaitannya dengan business understanding, beberapa rekomendasi untuk pengembangan model selanjutnya:

1. **Untuk Meningkatkan Directional Accuracy:**
   - Integrasi data eksternal seperti sentimen pasar dan berita
   - Pengembangan model khusus untuk klasifikasi arah pergerakan
   - Implementasi ensemble methods yang mengkombinasikan berbagai model

2. **Untuk Meningkatkan Ketahanan terhadap Volatilitas Ekstrem:**
   - Implementasi regime-switching models yang adaptif terhadap perubahan volatilitas
   - Pengembangan early warning system untuk mendeteksi potensi volatilitas tinggi
   - Stratifikasi data training berdasarkan level volatilitas

3. **Untuk Aplikasi Praktis:**
   - Pengembangan dashboard interaktif untuk visualisasi prediksi dan interval kepercayaan
   - Implementasi sistem alert untuk kondisi pasar dimana model mungkin kurang akurat
   - Integrasi dengan alat analisis portofolio untuk optimasi alokasi aset

Dengan mengimplementasikan rekomendasi ini, model diharapkan dapat mengatasi keterbatasan yang teridentifikasi dan memberikan nilai tambah lebih besar bagi investor dalam pengambilan keputusan terkait saham Microsoft.
"""